from typing import Any, List, Union, Tuple, Callable, Dict

# Définition de la classe Tableau
class Tableau:
    def __init__(self, data: Union[List[int], List[List[int]]]):
        self.data = data
        if all(isinstance(i, list) for i in data):
            self._shape = (len(data), len(data[0]))
        else:
            self._shape = (len(data),)
    
    def __contains__(self, item: int) -> bool:
        return item in self.data

    def __add__(self, other: Union['Tableau', int, float]) -> 'Tableau':
        return self._operation_element_par_element(other, lambda x, y: x + y)
    
    def __mul__(self, other: Union['Tableau', int, float]) -> 'Tableau':
        return self._operation_element_par_element(other, lambda x, y: x * y)
    
    def __sub__(self, other: Union['Tableau', int, float]) -> 'Tableau':
        return self._operation_element_par_element(other, lambda x, y: x - y)
    
    def __truediv__(self, other: Union['Tableau', int, float]) -> 'Tableau':
        return self._operation_element_par_element(other, lambda x, y: x / y)
    
    def __matmul__(self, other: 'Tableau') -> Union[int, float]:
        if self.shape != other.shape:
            raise ValueError("Les formes doivent être identiques pour les opérations élémentaires")
        if len(self.shape) != 1 or len(other.shape) != 1:
            raise ValueError("Le produit matriciel est uniquement supporté pour les tableaux 1D")
        return sum(a * b for a, b in zip(self.data, other.data))
    
    def __repr__(self) -> str:
        return f"Tableau({self.data})"
    
    def __getitem__(self, index: Union[int, Tuple[int, int]]) -> Union[int, List[int]]:
        if isinstance(index, int):
            return self.data[index]
        elif isinstance(index, tuple) and len(index) == 2:
            ligne, col = index
            return self.data[ligne][col]
        elif isinstance(index, tuple) and all(isinstance(i, slice) for i in index):
            slice_ligne, slice_col = index
            return Tableau([ligne[slice_col] for ligne in self.data[slice_ligne]])
        elif isinstance(index, slice):
            return Tableau(self.data[index])
        else:
            raise TypeError("Type d'index invalide")
    
    def __setitem__(self, index: Union[int, Tuple[int, int]], value: Union[int, float]):
        if isinstance(index, int):
            self.data[index] = value
        elif isinstance(index, tuple) and len(index) == 2:
            ligne, col = index
            self.data[ligne][col] = value
        else:
            raise TypeError("Type d'index invalide")
    
    def _operation_element_par_element(self, other: Union['Tableau', int, float], op: Callable[[Union[int, float], Union[int, float]], Union[int, float]]) -> 'Tableau':
        if isinstance(other, Tableau):
            if self.shape != other.shape:
                raise ValueError("Les formes doivent être identiques pour les opérations élémentaires")
            if len(self.shape) == 1:
                return Tableau([op(a, b) for a, b in zip(self.data, other.data)])
            else:
                return Tableau([[op(a, b) for a, b in zip(ligne_a, ligne_b)] for ligne_a, ligne_b in zip(self.data, other.data)])
        elif isinstance(other, (int, float)):
            if len(self.shape) == 1:
                return Tableau([op(a, other) for a in self.data])
            else:
                return Tableau([[op(a, other) for a in ligne] for ligne in self.data])
        else:
            raise ValueError("Opération non supportée")
    
    @property
    def shape(self) -> Tuple[int, ...]:
        return self._shape
    
    @shape.setter
    def shape(self, value: Tuple[int, int]):
        self._shape = value
    
    def get_function_by_number(self, num: int) -> Callable:
        fonctions: Dict[int, Callable] = {
            1: self.__add__, 2: self.__sub__, 3: self.__mul__, 4: self.__truediv__, 5: self.__matmul__,
            6: self.__contains__, 7: self.__getitem__, 8: self.__setitem__,
        }
        if num in fonctions:
            return fonctions[num]
        else:
            raise ValueError("Numéro de fonction invalide")
    
    def __len__(self) -> int:
        return len(self.data)


def create_tableau_from_input() -> Tableau:
    print("Entrez les dimensions du tableau (par exemple '2' pour 1D, '2,3' pour 2D) :")
    dimensions = input().strip()
    
    if ',' in dimensions:
        shape = tuple(map(int, dimensions.split(',')))
        data = []
        print(f"Entrez {shape[0]} lignes de {shape[1]} nombres chacune :")
        for _ in range(shape[0]):
            ligne = list(map(int, input().strip().split()))
            if len(ligne) != shape[1]:
                raise ValueError(f"On attendait {shape[1]} nombres par ligne, mais on en a obtenu {len(ligne)}")
            data.append(ligne)
    else:
        shape = (int(dimensions),)
        print(f"Entrez {shape[0]} nombres :")
        data = list(map(int, input().strip().split()))
        if len(data) != shape[0]:
            raise ValueError(f"On attendait {shape[0]} nombres, mais on en a obtenu {len(data)}")
    
    return Tableau(data)


if __name__ == "__main__":
    while True:
        print("Choisissez une opération :")
        print("1-) Additionner deux tableaux")
        print("2-) Soustraire deux tableaux")
        print("3-) Multiplier deux tableaux")
        print("4-) Diviser deux tableaux")
        print("5-) Produit scalaire de deux tableaux")
        print("6-) Vérifier si un élément existe dans un tableau")
        print("7-) Accéder à un élément d'un tableau")
        print("8-) Quitter")

        choix = int(input("Entrez le numéro de l'opération : "))

        if choix in [1, 2, 3, 4, 5]:
            print("Entrez le premier tableau :")
            tab1 = create_tableau_from_input()
            
            print("Entrez le deuxième tableau :")
            tab2 = create_tableau_from_input()
            
            operation = tab1.get_function_by_number(choix)
            resultat = operation(tab2)
            print(f"Résultat : {resultat}")
        
        elif choix == 6:
            print("Entrez la valeur de l'élément à rechercher :")
            element = int(input().strip())
            
            print("Entrez le tableau :")
            tab = create_tableau_from_input()
            
            print(f"Elément {element} dans le premier tableau : {element in tab}")
        
        elif choix == 7:
            print("Entrez l'index de l'élément à récupérer :")
            index = eval(input().strip())  # Utilisation de eval pour analyser l'entrée en tuple
            
            print("Entrez le tableau :")
            tab = create_tableau_from_input()
            
            resultat = tab[index]
            print(f"Élément à l'index {index} : {resultat}")
        
        elif choix == 8:
            print("Sortie...")
            break  # Quitter la boucle et terminer le programme
        
        else:
            print("Choix invalide")
        
        # Afficher à nouveau le menu après chaque opération
        print()
        print("=" * 20)
        print()
